@{
    ViewData["Title"] = "Voice Chat with AI";
    Layout = "../Shared/_AiVoiceLayout";
}

@Html.AntiForgeryToken()

<a class="home-button" href="/Home/Index">
    <span>Quay lại</span>
</a>

<div class="voice-chat-container">
    <div class="ai-avatar-section">
        <div class="avatar-container">
            <img id="aiAvatar" src="/images/voice-chat/ai-avatar-1.jpg" alt="AI Avatar" class="ai-avatar" />
            <div class="avatar-glow"></div>
        </div>

        <div class="chat-info">
            <h1 class="ai-name">Tôi là <span class="highlight-pink">Kim Ấn</span>, trợ lý <span class="highlight-cyan">ảo</span> của bạn</h1>
        </div>

        <div class="voice-controls">
            <div id="listeningIndicator" class="listening-indicator" style="display: none;">
                <img src="/images/voice-chat/user-voice.gif" alt="Listening" class="status-gif" />
            </div>

            <div id="processingIndicator" class="processing-indicator" style="display: none;">
                <img src="/images/voice-chat/loading.gif" alt="Processing" class="status-gif" />
                <p>Bạn đợi một xíu nhé...</p>
            </div>

            <button id="voiceButton" class="voice-btn">
                <i class="mic-icon">🎤</i>
                <span class="btn-text">Nhấn để nói chuyện với tôi</span>
            </button>
        </div>
    </div>
</div>

<script>
    class VoiceChat {
        constructor() {
            this.mediaRecorder = null;
            this.audioContext = null;
            this.stream = null;
            this.audioChunks = [];
            this.isRecording = false;
            this.isPlaying = false;

            this.voiceButton = document.getElementById('voiceButton');
            this.listeningIndicator = document.getElementById('listeningIndicator');
            this.processingIndicator = document.getElementById('processingIndicator');
            this.aiAvatar = document.getElementById('aiAvatar');

            this.bindEvents();
        }

        bindEvents() {
            this.voiceButton.addEventListener('click', () => {
                if (this.isRecording) {
                    this.stopRecording();
                } else if (this.isPlaying) {
                    this.stopPlaying();
                } else {
                    this.startRecording();
                }
            });
        }

        async startRecording() {
            try {
                this.stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                // Tạo AudioContext để xử lý audio
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                const source = this.audioContext.createMediaStreamSource(this.stream);
                const processor = this.audioContext.createScriptProcessor(4096, 1, 1);

                this.audioChunks = [];

                processor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);
                    const int16Data = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        int16Data[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                    }
                    this.audioChunks.push(int16Data);
                };

                source.connect(processor);
                processor.connect(this.audioContext.destination);

                this.isRecording = true;
                this.showListening();

            } catch (error) {
                console.error('Microphone access error:', error);
                alert('Không thể truy cập microphone');
            }
        }

        stopRecording() {
            if (!this.isRecording) return;

            this.isRecording = false;

            if (this.audioContext) {
                this.audioContext.close();
            }

            if (this.stream) {
                this.stream.getTracks().forEach(track => track.stop());
            }

            this.hideListening();
            this.showProcessing();
            this.processAudio();
        }

        async processAudio() {
            try {
                if (this.audioChunks.length === 0) {
                    throw new Error('Không có dữ liệu audio');
                }

                if (this.isSilent(this.audioChunks)) {
                    throw new Error('Phát hiện im lặng, không gửi yêu cầu.');
                }

                // Tạo WAV file từ audio chunks
                const wavBlob = this.createWavBlob(this.audioChunks, 16000);

                if (wavBlob.size < 1000) {
                    throw new Error('Audio quá ngắn');
                }

                const formData = new FormData();
                formData.append('audioFile', wavBlob, 'recording.wav');
                formData.append('__RequestVerificationToken',
                    document.querySelector('input[name="__RequestVerificationToken"]').value);

                const response = await fetch('/Ais/ProcessVoiceChat', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${errorText}`);
                }

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                this.playAudio(audioUrl);

            } catch (error) {
                console.log('Lỗi xử lý: ' + error.message);
            } finally {
                this.hideProcessing();
            }
        }

        isSilent(chunks) {
            const threshold = 100; // Ngưỡng để xác định im lặng, bạn có thể cần điều chỉnh
            let totalSamples = 0;
            let sumOfSquares = 0;

            for (const chunk of chunks) {
                for (let i = 0; i < chunk.length; i++) {
                    const sample = chunk[i];
                    sumOfSquares += sample * sample;
                }
                totalSamples += chunk.length;
            }

            if (totalSamples === 0) return true;

            // Tính toán Root Mean Square-một cách đo năng lượng/độ lớn của tín hiệu
            const rms = Math.sqrt(sumOfSquares / totalSamples);
            return rms < threshold;
        }

        createWavBlob(audioChunks, sampleRate) {
            // Gộp tất cả audio chunks
            let totalLength = 0;
            audioChunks.forEach(chunk => totalLength += chunk.length);

            const audioData = new Int16Array(totalLength);
            let offset = 0;
            audioChunks.forEach(chunk => {
                audioData.set(chunk, offset);
                offset += chunk.length;
            });

            // Tạo WAV header
            const buffer = new ArrayBuffer(44 + audioData.length * 2);
            const view = new DataView(buffer);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + audioData.length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, audioData.length * 2, true);

            // Audio data
            const audioBytes = new Uint8Array(buffer, 44);
            for (let i = 0; i < audioData.length; i++) {
                const sample = audioData[i];
                audioBytes[i * 2] = sample & 0xff;
                audioBytes[i * 2 + 1] = (sample >> 8) & 0xff;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        playAudio(url) {
            const audio = new Audio(url);
            this.currentAudio = audio;
            audio.play();

            audio.onplay = () => {
                this.isPlaying = true;
                this.aiAvatar.classList.add('speaking');
                this.updateButton();
            };

            audio.onended = () => {
                this.isPlaying = false;
                this.aiAvatar.classList.remove('speaking');
                this.updateButton();
                URL.revokeObjectURL(url);
            };
        }

        stopPlaying() {
            if (this.currentAudio) {
                this.currentAudio.pause();
                this.currentAudio.currentTime = 0;
                this.isPlaying = false;
                this.aiAvatar.classList.remove('speaking');
                this.updateButton();
            }
        }

        showListening() {
            this.listeningIndicator.style.display = 'block';
            this.updateButton();
        }

        hideListening() {
            this.listeningIndicator.style.display = 'none';
        }

        showProcessing() {
            this.processingIndicator.style.display = 'block';
            this.voiceButton.classList.add('hidden');
        }

        hideProcessing() {
            this.processingIndicator.style.display = 'none';
            this.voiceButton.classList.remove('hidden');
            this.updateButton();
        }

        updateButton() {
            const btn = this.voiceButton;
            const text = btn.querySelector('.btn-text');

            btn.classList.remove('listening', 'speaking');

            if (this.isRecording) {
                text.textContent = 'Nhấn để dừng ghi âm';
                btn.classList.add('listening');
            } else if (this.isPlaying) {
                text.textContent = 'Nhấn để dừng phát';
                btn.classList.add('speaking');
            } else {
                text.textContent = 'Nhấn để nói chuyện với tôi';
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => new VoiceChat());
</script>

